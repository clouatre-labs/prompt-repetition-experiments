{"session_id":"control-3","lens":"scout","issue_summary":"Replace anti-pattern use of id(ctx.lifespan_context) as session ID with proper FastMCP 3.0 ctx.set_state()/ctx.get_state() API using UUIDs","relevant_files":[{"path":"src/math_mcp/tools/persistence.py","line_range":"63, 77-78","role":"Primary target: contains id(ctx.lifespan_context) in save_calculation metadata and history append in load_variable"},{"path":"src/math_mcp/tools/calculate.py","line_range":"61-62","role":"Secondary target: contains id(ctx.lifespan_context) history append in calculate tool"},{"path":"tests/test_persistence.py","line_range":"50-62, 170-185","role":"Test fixtures and assertions that mock lifespan_context.calculation_history"},{"path":"tests/test_math_operations.py","line_range":"97-100, 115-125","role":"Test fixtures that mock lifespan_context for calculate tool testing"},{"path":"src/math_mcp/server.py","line_range":"1-50","role":"Server setup and AppContext definition for understanding lifespan scope"}],"conventions":{"commits":"Conventional Commits with GPG sign and DCO sign-off: git commit -S --signoff","testing":"pytest with AsyncMock, AAA pattern (Arrange-Act-Assert), one happy path and edge case per behavior","linting":"ruff check and ruff format with pyright type checking","error_handling":"Graceful fallback to None when ctx unavailable; no exceptions for missing context","imports":"Type hints with SkipValidation[Context | None] = None pattern for optional context"},"patterns":["Optional context parameter: ctx: SkipValidation[Context | None] = None","Null-check before use: if ctx and ctx.lifespan_context: ...","History tracking via ctx.lifespan_context.calculation_history.append()","Metadata dict with optional session_id field","MockContext fixture with synthetic lifespan_context object for testing"],"related_issues":[{"number":221,"title":"Add progress reporting to statistics tools","relevance":"Related refactor showing proper use of ctx API (ctx.report_progress); demonstrates pattern of using ctx methods correctly"}],"constraints":["ctx must remain optional (Context | None = None) for backward compatibility","Session ID must be serializable (UUID string, not object)","ctx.set_state() is session-scoped (per client connection), not process-scoped","Must not store non-serializable values via ctx.set_state","Fallback to None session_id when ctx unavailable (non-breaking change)","Tests must pass unchanged (mock context still needed for unit tests)"],"test_coverage":"Comprehensive test coverage exists: test_persistence.py tests save_calculation and load_variable with mock context; test_math_operations.py tests calculate tool with mock context. Both use MockContext fixture with synthetic lifespan_context.calculation_history list. Tests verify history entries are appended correctly. New approach requires updating mock context to support set_state/get_state methods.","library_findings":[{"library":"fastmcp","version":">=3.0.0","relevant_api":"Context.set_state(key: str, value: Any) and Context.get_state(key: str) -> Any | None","notes":"Session-scoped state management API introduced in FastMCP 3.0. Persists across requests within same MCP session. Proper replacement for lifespan_context for per-session identifiers. Reference: https://gofastmcp.com/servers/context#session-state"},{"library":"uuid","version":"stdlib","relevant_api":"uuid.uuid4() -> UUID, str(uuid.uuid4()) for serializable string representation","notes":"Standard library module for generating unique identifiers. uuid4() generates random UUIDs suitable for session IDs. Must convert to string for serialization via ctx.set_state()"},{"library":"pydantic","version":">=2.12.0","relevant_api":"Field validation, SkipValidation type hint","notes":"Already used in project for validation. No changes needed for this refactor."}],"approaches":[{"name":"Approach 1: Lazy UUID Generation with ctx.set_state (Recommended)","description":"On first request in a session, initialize session_id via ctx.set_state(). On subsequent requests, retrieve via ctx.get_state(). Fallback to None when ctx unavailable. Apply to both persistence.py (line 63) and calculate.py (line 61-62). Update test mocks to support async set_state/get_state methods.","implementation_steps":["Add 'import uuid' to both persistence.py and calculate.py","Create helper function: async def _get_session_id(ctx: Context | None) -> str | None that calls ctx.set_state/get_state with UUID initialization","Replace 'id(ctx.lifespan_context) if ctx and ctx.lifespan_context else None' with await _get_session_id(ctx)","Update MockContext in test files to include async set_state(key, value) and get_state(key) methods with internal dict storage","Update test assertions to verify session_id is a valid UUID string, not a memory address","Add inline comment explaining why ctx.set_state is used over lifespan_context"],"pros":["Correct FastMCP 3.0 pattern for session-scoped data","UUID is stable and serializable (unlike memory addresses)","Lazy initialization avoids UUID generation if ctx unavailable","Backward compatible: fallback to None when ctx is None","Minimal code changes: one helper function replaces two locations","Tests remain simple: mock just needs dict-based state storage","Educational value: demonstrates proper API usage for learners"],"cons":["Requires async/await in helper function (adds slight complexity)","Test mocks become slightly more complex (need async methods)","Requires understanding of session-scoped vs process-scoped state","UUID generation happens on first request (negligible perf impact)"],"complexity":"medium","files_touched":4,"code_sample":"async def _get_session_id(ctx: Context | None) -> str | None:\n    if ctx is None:\n        return None\n    session_id = await ctx.get_state('session_id')\n    if session_id is None:\n        session_id = str(uuid.uuid4())\n        await ctx.set_state('session_id', session_id)\n    return session_id"},{"name":"Approach 2: Inline UUID with Immediate ctx.set_state","description":"Generate UUID immediately on each tool call and set via ctx.set_state(). Retrieve on subsequent calls. No helper function. Inline the logic directly in save_calculation and calculate. More verbose but explicit.","implementation_steps":["Add 'import uuid' to both files","In save_calculation (line 63): Replace session_id assignment with inline async call to ctx.set_state/get_state","In calculate (line 61-62): Same replacement for history tracking","Update test mocks to support async set_state/get_state","Add comments at each location explaining the pattern"],"pros":["No additional helper function (less abstraction)","Explicit at point of use (easier to understand locally)","Same correctness as Approach 1","Backward compatible fallback to None"],"cons":["Code duplication across two files (violates DRY)","More verbose (more lines of code per tool)","Harder to maintain if pattern needs to change","Less reusable if other tools need session IDs later","Requires async/await in tool functions (changes signature)"],"complexity":"medium","files_touched":4},{"name":"Approach 3: Module-Level Session Cache with Fallback","description":"Create a module-level dict to cache session IDs keyed by context identity (using id(ctx) as key, not id(lifespan_context)). On first request, generate UUID and cache. On subsequent requests, retrieve from cache. Fallback to None when ctx unavailable. No ctx.set_state needed.","implementation_steps":["Add module-level dict: _session_cache: dict[int, str] = {} at top of persistence.py","Create helper: def _get_session_id(ctx: Context | None) -> str | None that manages cache","Replace id(ctx.lifespan_context) with _get_session_id(ctx)","Update test mocks to work with context identity caching","Add comment explaining why caching is used"],"pros":["No async/await required (simpler function signatures)","No changes to test mock signatures (mocks don't need async methods)","Works with existing test structure","Fast lookup via dict (O(1))","Avoids learning curve of ctx.set_state API"],"cons":["Still uses id() as key (same anti-pattern as original, just different object)","Cache is process-scoped, not session-scoped (incorrect scope)","Cache persists across sessions (potential memory leak)","Does not demonstrate proper FastMCP 3.0 API (educational value lost)","Violates issue intent: 'remove the hack'","Cache invalidation complexity (when to clear?)","Not the pattern recommended in FastMCP docs"],"complexity":"simple","files_touched":3,"recommendation_note":"Not recommended: does not address core issue of using id() as identifier; still a hack"}],"recommendation":"Approach 1 (Lazy UUID Generation with ctx.set_state) is strongly recommended. It correctly implements FastMCP 3.0's session-scoped state API, generates stable UUIDs, maintains backward compatibility with None fallback, and demonstrates the proper pattern for learners. The helper function minimizes code duplication and makes the pattern reusable for future tools. Test mocks require minimal changes (adding async set_state/get_state methods with dict storage). This approach directly addresses the issue's acceptance criteria and reference documentation.","estimated_effort":{"code_changes":"30 minutes (two file edits, one helper function, import additions)","test_updates":"20 minutes (update two mock context fixtures, verify assertions)","testing_and_verification":"15 minutes (run pytest, verify no regressions)","total":"65 minutes"}}
